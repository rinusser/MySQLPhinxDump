<?php
declare(strict_types=1);
/**
 * Requires PHP version 7.0+.
 * @author Richard Nusser
 * @copyright 2017 Richard Nusser
 * @license GPLv3 (see http://www.gnu.org/licenses/)
 * @link https://github.com/rinusser/PhinxDump
 */

namespace RN\PhinxDump;

use RN\PhinxDump\Model;
use RN\PhinxDump\CodeGenerator\AbstractCodeGenerator;
use RN\PhinxDump\CodeGenerator\ColumnCodeGenerator;

/**
 * This class takes various models and turns them into parts of migration classes.
 * Columns are handled in ColumnCodeGenerator.
 */
abstract class MigrationCodeGenerator extends AbstractCodeGenerator
{
  public static $allowEmptyMigration=false;


  /**
   * Turns an index model into a Phinx ->addIndex() function call
   *
   * @param Index $index the index to generate code for
   * @return string the generated function call code
   */
  public static function generateAddIndexCode(Model\Index $index): string
  {
    $limits=array_filter($index->columnSubparts);
    $count=count($limits);
    $limit_string='';
    if($count>1)
      throw new UnsupportedSchemaException("index '$index->name': multiple column subparts currently not supported as of Phinx 0.8");
    elseif($count==1)
    {
      if(array_keys($limits)[0]!=count($index->columnSubparts)-1)
        throw new UnsupportedSchemaException("index '$index->name': column subpart only supported on last column as of Phinx 0.8");
      $limit_string=",'limit'=>".array_pop($limits);
    }
    return "->addIndex(".self::_generateArray($index->columns).",['unique'=>".($index->unique?'true':'false').$limit_string.",'name'=>'".$index->name."'])";
  }

  /**
   * Turns a table model into a Phinx $this->table() ... ->create() call
   *
   * @param Table  $table  the table to generate code for
   * @param string $indent (optional) the indenting to use for chained function calls
   * @return string the generated code to create the entire table (includes all columns and indices)
   */
  public static function generateTableCode(Model\Table $table, string $indent='    '): string
  {
    $options=['id'=>'false'];
    if($table->primaryKey)
      $options['primary_key']=self::_generateArray($table->primaryKey->columns);
    if($table->comment)
      $options['comment']=trim(var_export($table->comment,true));
    if($table->engine)
      $options['engine']=var_export($table->engine,true);
    $code_comment=$table->codeComment?' //'.str_replace(["\r","\n"],' ',$table->codeComment):'';
    $rvs=['$this->table(\''.$table->name."',".self::_generateArray($options,true,false).')'.$code_comment];
    foreach($table->columns as $column)
      $rvs[]=ColumnCodeGenerator::generateAddColumnCode($column);
    foreach($table->indices as $index)
      $rvs[]=self::generateAddIndexCode($index);
    $rvs[]='->create();';
    return implode("\n".$indent."     ",$rvs);
  }

  /**
   * Generates a migration file from blocks of migration parts (e.g. table creations)
   *
   * @param string $classname                      the class's name
   * @param array  $code_blocks                    the list of code blocks (e.g. generated by generateTableCode()) to include in the migration
   * @param array  $additional_class_comment_lines (optional) additional lines of class comments
   * @return string the generated code, ready for writing to a .php file
   */
  public static function generateClassCode(string $classname, array $code_blocks, array $additional_class_comment_lines=[]): string
  {
    $logger=Logger::getInstance();
    if(!$code_blocks)
    {
      if(!self::$allowEmptyMigration)
      {
        $logger->error('database is empty, didn\'t create a migration class');
        return '';
      }
      else
      {
        $logger->warn('database is empty, created migration class anyway');
        $code_blocks=['//original database was empty'];
      }
    }

    $template='<?php
declare(strict_types=1);
/**
 * Database migration generated by reverse-engineering live MySQL database
 *
[[COMMENTS]]
 *
 * Requires PHP version 7.0+
 * @codingStandardsIgnoreRule RN.Classes.ClassDeclaration
 */

use Phinx\Migration\AbstractMigration;
use Phinx\Db\Adapter\MysqlAdapter;

/**
 * Phinx database migration class
 */
class [[CLASSNAME]] extends AbstractMigration
{
  /**
   * Perform migration (gets called by Phinx)
   *
   * @return void
   */
  public function change()
  {
    [[CODE]]
  }
}
';
    $replacements=['[[COMMENTS]]'=>' * '.implode("\n * ",$additional_class_comment_lines),
                   '[[CLASSNAME]]'=>$classname,
                   '[[CODE]]'=>implode("\n\n    ",$code_blocks)];
    return str_replace(array_keys($replacements),array_values($replacements),$template);
  }
}
